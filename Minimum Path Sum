class Solution {  //strivers
public:

/*
    //using recursion
    //t.c: 2^(m*n)  s.c:O(path length)=O(m-1 + n-1)
    //TLE because of exponential t.c //hence we'll use memoization to resolve tle
    int f(int i,int j,vector<vector<int>>& grid){
        //base case
        if(i==0 && j==0) return grid[i][j];
        if(i<0 || j<0) return 1e9;  //-> neglecting 
        
        

        int up=grid[i][j]+f(i-1,j,grid);
        int left=grid[i][j]+f(i,j-1,grid);
        return min(left,up);

    }
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        
        return f(m-1,n-1,grid);
    }




    //using recursion + memoization(to resove TLE)
    //t.c:O(n*m) //s.c:O(m-1 + n-1) + O(n*m) -> path length + dp array
    int f(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){
        //base case
        if(i==0 && j==0) return grid[i][j];
        if(i<0 || j<0) return 1e9;  //imp
        

        if(dp[i][j]!=-1) return dp[i][j];
        
        int up=grid[i][j]+f(i-1,j,grid,dp);
        int left=grid[i][j]+f(i,j-1,grid,dp);
        return dp[i][j]=min(left,up);

    }
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,-1));
        return f(m-1,n-1,grid,dp);
    }

    */

/*
    //using tabulation (bottom up apraoch) //to further remove space complexity of recursion stack space
    //t.c:O(n*m)   s.c:O(n*m)
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0 && j==0) dp[i][j]=grid[i][j];
                else{
                    int up=grid[i][j];
                    if(i>0) up+=dp[i-1][j];
                    else up+= 1e9;  //means neglecting the path if i<0

                    int left=grid[i][j];
                    if(j>0) left+=dp[i][j-1];
                    else left+=1e9;


                    dp[i][j]=min(up,left);
                }
            }
        }
        return dp[m-1][n-1];
    }

 */
    //now further using space optimisation 
    //t.c:O(n*m)   s.c:O(n)
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
         vector<int> prev(n,0); 
        for(int i=0;i<m;i++){
            vector<int> curr(n,0); 
            for(int j=0;j<n;j++){
                if(i==0 && j==0) curr[j]=grid[i][j];
                else{
                    int up=grid[i][j];
                    //requiring previous row's j colulmn
                    if(i>0) up+=prev[j];
                    else up+= 1e9+7;  //means neglecting the path if i<0

                    int left=grid[i][j];
                    //requiring current row's j-1 colulmn
                    if(j>0) left+=curr[j-1];
                    else left+=1e9+7;


                    curr[j]=min(up,left);
                }
            }
            prev=curr;
        }
        return prev[n-1];  //since at i=m ; for loop ends  -> isiliye m-1 will be prev
    }



};
